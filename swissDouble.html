<html>
  <head>
    <meta charset="UTF-8" />

    <title>Schweizer Doppel</title>
    <style>:root {
  --color-action: #007bff;
  --color-ok: #cdffdd;
  --color-alert: #dc143c;
  --color-alert-transparent: #dc143c77;
  --color-green: #28a745;
  --color-yellow: #ffc107;
  --color-white: #f8f9fa;
  --color-black: #343a40;
  --color-subtle: #eee;
  --color-subtle-highlight: #d0d8fe;
  --color-light: #aaa;
  --color-light-transparent: #aaaaaabb;
  --color-light: #aaa;
  --font: sans-serif;
  --font-size: 20px;
  --max-width: 900px;

  --border-radius: 8px;
}

#universe {
  max-width: var(--max-width);
  margin: auto;
  font-family: var(--font);
}

.flex {
  display: flex;
  gap: 12px;
}

.relative {
  position: relative;
}

.flex-grow {
  flex-grow: 1;
}

.flex-section {
  flex: 1 1 0px;
  width: 0;
}

.width-100 {
  width: 100%;
}

.center {
  /* needs to be wrapped in a .flex div to take effect */
  margin-left: auto;
  margin-right: auto;
}

.right {
  /* needs to be wrapped in a .flex div to take effect */
  margin-left: auto;
}

.btn {
  font-size: 20px;
  border: None;
  border-radius: var(--border-radius);
  padding: 12px;
}

.fw-normal {
  font-weight: normal;
}

.btn-action {
  margin-top: 12px;
  background: var(--color-action);
  color: var(--color-white);
  font-weight: bold;
  border: None;
}

.btn-green {
  background: var(--color-green);
  color: var(--color-white);
}

.btn-yellow {
  background: var(--color-yellow);
  color: var(--color-black);
}

.btn-alert {
  color: var(--color-alert);
  border-color: var(--color-alert);
  background: #f8d7da;
  border-width: 2px;
}

h1,
h2 {
  font-weight: normal;
  margin: 0px 0px 6px 0px;
  padding: 0;
}

.border {
  border: 2px solid black;
  border-radius: var(--border-radius);
}

.page {
  padding: 12px;
  margin: 12px;
}
#round-view .match {
  margin-bottom: 8px;
  padding: 4px 0px;
  background: var(--color-subtle);
  font-size: var(--font-size);
  border-radius: var(--border-radius);
  display: flex;
  justify-content: space-evenly;
}

#round-view .match .team {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

.points {
  font-weight: normal;
}

#round-view .match .result {
  display: flex;
  gap: 6px;
  font-size: var(--font-size);
  width: 4em;
}

#round-view .match .result .conjunctor {
  margin: auto;
}

#round-view .match:has(.result .set),
#round-view .match.freegame {
  background: var(--color-ok);
}

#round-view .match.tie,
#round-view .match.invalid {
  background: var(--color-alert-transparent);
}

#round-view.fixed-round .match,
#round-view.fixed-round .match .result .btn-result {
  background: var(--color-subtle) !important;
  color: var(--color-light) !important;
}

#round-view.fixed-round h2 {
  color: var(--color-light) !important;
}

#round-view .btn-result {
  background: white;
  border: None;
  width: calc(var(--font-size) + 24px);
  margin: auto 0;
  vertical-align: middle;
}
#round-nav {
  padding: 0px 24px;
  margin: 12px;
  border-radius: var(--border-radius);
  background: var(--color-subtle);
  display: flex;
  gap: 0;
  justify-content: space-between;
}

#round-nav div {
  padding: 12px;
  border-radius: var(--border-radius);
  font-size: var(--font-size);
}

#round-nav div:not(.inactive) {
  cursor: pointer;
}

#round-nav div:hover:not(.inactive) {
  background: var(--color-subtle-highlight);
}

.nav-round.future-round {
  color: var(--color-light);
}

.nav-round.focus {
  border: 2px solid var(--color-action);
  font-weight: bold;
}

.nav-round.add-round-button {
  cursor: pointer;
  font-weight: bold;
  background: var(--color-subtle-highlight);
  color: var(--color-white);
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 40px;
}

.nav-round.add-round-button:hover {
  background: var(--color-action) !important;
}
#reopen-round-confirmation {
  z-index: 2;
  width: 100%;
  height: 100%;
  background: var(--color-alert-transparent);
  position: absolute;
  top: 0;
  left: 0;
  font-size: var(--font-size);
  display: flex;
}

.confirmation-body {
  margin: auto;
  background: var(--color-white);
  border-radius: var(--border-radius);
  padding: 20px;
  max-width: var(--max-width);
  border: 4px solid var(--color-alert);
}

.confirmation-message {
  padding: 20px;
}

.confirmation-body button {
  min-width: 5em;
}
#ranking-table table.result-table {
  margin-top: 24px;
  width: 100%;
}

#ranking-table th {
  text-align: left;
  font-weight: bold;
}

#ranking-table tr.dark {
  background: var(--color-subtle);
}

#ranking-table tr.departed {
  opacity: 0.6;
  font-style: italic;
}

#ranking-table table {
  border-collapse: collapse;
}
#open-dialog {
  position: relative;
  display: inline-block;
  background: var(--color-white);
  border: 2px solid var(--color-black);
  border-radius: var(--border-radius);
  width: 30em;
  top: 4px;
  box-shadow: 10px 5px 5px var(--color-white);
}

#open-dialog .dropdown {
  position: absolute;
  display: inline-block;
  z-index: 1;
}

#open-dialog .dropdown-dialog-row:not(last-child) {
  display: block;
  background: var(--color-white);
  padding: 12px;
  font-size: var(--font-size);
  border-bottom: 1px solid var(--color-black);
}

#open-dialog .dropdown-dialog-row:hover {
  background: var(--color-subtle-highlight);
}
.manage-players-body {
  width: 90vw;
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
}

.manage-players-subtitle {
  color: var(--color-light);
  margin-bottom: 20px;
  font-size: 16px;
}

.manage-players-list {
  margin: 20px 0;
}

.manage-player-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px;
  margin-bottom: 10px;
  background: var(--color-subtle);
  border-radius: var(--border-radius);
  min-height: 60px;
}

.player-info {
  flex-grow: 1;
}

.player-name {
  font-weight: bold;
  font-size: var(--font-size);
  margin-bottom: 4px;
}

.player-points {
  color: var(--color-light);
  font-size: 16px;
}

.remove-player-btn {
  min-width: 100px;
  margin-left: 15px;
  font-size: 16px;
  padding: 10px 15px;
}

/* Mobile responsiveness */
@media (max-width: 600px) {
  .manage-player-row {
    flex-direction: column;
    align-items: stretch;
    text-align: center;
    padding: 20px 15px;
  }

  .player-info {
    margin-bottom: 15px;
  }

  .remove-player-btn {
    margin-left: 0;
    width: 100%;
  }
}
#header {
  overflow: hidden;
  display: flex;
  gap: 12px;
}

#header .left-group {
  margin-right: auto;
}

#header .right-group {
  margin-left: auto;
}

#header .section {
  float: left;
  display: inline;
  width: 10em;
  margin: 0px 8px;
}

#open-tournament-section {
  /* This is for the positioning of the dropdown */
  position: absolute;
}
#footer {
  text-align: center;
  padding: 24px 12px;
  margin-top: 24px;
  color: var(--color-light);
  font-size: var(--font-size);
}

#footer a {
  color: var(--color-light);
}

#footer a:hover {
  color: var(--color-black);
}
#data-form {
  --line-height: 1.2;
}

#data-form .input {
  width: 100%;
  font-size: var(--font-size) !important;
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

#data-form .label {
  margin-top: 12px;
  margin-bottom: 4px;
  font-size: var(--font-size) !important;
  line-height: var(--line-height) !important;
  font-weight: bold;
}

#data-form .number-input-group {
  margin-left: 16px;
  min-width: 80px;
  flex-shrink: 0;
}

#data-form .input-number {
  width: 80px;
}

#data-form #input-participants {
  width: 100%;
}

.textarea-with-numbers {
  margin-top: var(--font-size);
  display: flex;
  border: 1px solid #ccc;
  border-radius: 4px;
  overflow: hidden;
  background: white;
}

.line-numbers {
  font-family: inherit;
  font-size: var(--font-size) !important;
  line-height: var(--line-height) !important;
  background-color: var(--color-subtle);
  color: var(--color-light);
  margin: 0;
  padding: 2px 8px 2px 4px;
  text-align: right;
  user-select: none;
  border-right: 1px solid #dee2e6;
  min-width: 35px;
  overflow: hidden;
  white-space: pre;
  box-sizing: border-box;
}

#input-participants {
  border: none !important;
  outline: none;
  resize: none;
  flex: 1;
  font-family: inherit;
  font-size: var(--font-size) !important;
  line-height: var(--line-height) !important;
  padding: 2px;
  margin: 0;
  box-sizing: border-box;
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

.radio-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 4px;
}

.radio-label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-weight: normal;
  font-size: var(--font-size);
}

.radio-label input[type='radio'] {
  cursor: pointer;
  width: 18px;
  height: 18px;
}

.ranking-order-section {
  margin-top: 16px;
}

.ranking-order-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 4px;
}

.ranking-order-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: white;
}

.ranking-order-number {
  min-width: 24px;
  font-weight: bold;
}

.ranking-order-label {
  flex: 1;
}

.ranking-order-buttons {
  display: flex;
  gap: 4px;
}

.btn-ranking-order-up,
.btn-ranking-order-down {
  width: 32px;
  height: 32px;
  padding: 0;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-ranking-order-up:hover:not(:disabled),
.btn-ranking-order-down:hover:not(:disabled) {
  background: #f0f0f0;
}

.btn-ranking-order-up:disabled,
.btn-ranking-order-down:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.alert {
  z-index: 2;
  width: 100%;
  height: 100%;
  background: var(--color-light-transparent);
  position: absolute;
  top: 0;
  left: 0;
  font-size: var(--font-size);
  display: flex;
}

.alert-body {
  margin: auto;
  background: var(--color-white);
  border-radius: var(--border-radius);
  padding: 20px;
}

.alert-message {
  white-space: pre-line;
  padding: 20px;
}

.alert-body button {
  min-width: 5em;
}
</style>
    <script>"use strict";
(() => {
  // app/utils.ts
  var setDiff = (these, those) => new Set([...these].filter((element) => !those.includes(element)));
  var drawRandom = (set) => {
    let array = Array.from(set);
    return array[Math.floor(Math.random() * array.length)];
  };
  var findDuplicates = (array) => array.filter((item, index) => array.indexOf(item) !== index);
  var isTruthy = (value) => {
    try {
      return !!value.length;
    } catch {
    }
    try {
      return !!Object.keys(value).length;
    } catch {
    }
    try {
      return !!value.size;
    } catch {
    }
    return !!value;
  };
  var randomId = () => Math.random().toString(36).replace(/^0\./, "_");
  var groupBy = (array, comparator) => {
    if (!isTruthy(array)) return [];
    const groups = [];
    let currentGroup = [array[0]];
    for (const element of array.slice(1)) {
      if (comparator(currentGroup[0], element)) {
        currentGroup.push(element);
      } else {
        groups.push(currentGroup);
        currentGroup = [element];
      }
    }
    groups.push(currentGroup);
    return groups;
  };
  var popRandom = (list) => list.splice(Math.floor(Math.random() * list.length), 1)[0];

  // app/freeGamers.ts
  var DEFAULT_FREE_GAME_STRATEGY = "bottom-ranking";
  var getFreeGameCount = (player, history) => {
    let count = 0;
    for (const round of history) {
      for (const match of round) {
        if (!("isFreeGame" in match)) {
          continue;
        }
        if (match.player == player) {
          count++;
        }
      }
    }
    return count;
  };
  var selectByRanking = (eligiblePlayers, ranking, count) => {
    const rankingMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < ranking.length; i++) {
      rankingMap.set(ranking[i][0], i);
    }
    const sortedEligible = [...eligiblePlayers].sort((a, b) => {
      const rankA = rankingMap.get(a) ?? Infinity;
      const rankB = rankingMap.get(b) ?? Infinity;
      return rankA - rankB;
    });
    return sortedEligible.slice(0, count);
  };
  var selectRandom = (eligiblePlayers, count) => {
    const selected = [];
    const available = new Set(eligiblePlayers);
    for (let i = 0; i < count && available.size > 0; i++) {
      const player = drawRandom(available);
      selected.push(player);
      available.delete(player);
    }
    return selected;
  };
  var calculateFreeGamers = (participants, history, strategy = DEFAULT_FREE_GAME_STRATEGY) => {
    const rankingOrder = getRankingOrder();
    let ranking = calculateRanking(participants, history, rankingOrder);
    const participantCount = participants.length;
    const freeGamesCount = participantCount % 4;
    let freeGamers = [];
    if (freeGamesCount == 0) {
      return freeGamers;
    }
    const freeGameCounts = {};
    for (const participant of participants) {
      freeGameCounts[participant] = getFreeGameCount(participant, history);
    }
    const minFreeGames = Math.min(...Object.values(freeGameCounts));
    const eligiblePlayers = [];
    for (const [player, _] of ranking.reverse()) {
      if (freeGameCounts[player] === minFreeGames) {
        eligiblePlayers.push(player);
      }
    }
    if (strategy === "random") {
      return selectRandom(eligiblePlayers, freeGamesCount);
    } else {
      return selectByRanking(eligiblePlayers, ranking, freeGamesCount);
    }
  };

  // app/storage.ts
  var STORAGE_KEYS = [
    "history",
    "participants",
    "roundCount",
    "title",
    "departedPlayers",
    "savedTournaments",
    "correctingRound",
    "freeGameStrategy",
    "pairingStrategy",
    "setsToWin",
    "rankingOrder"
  ];
  var ROOT = "swiss-double";
  var getStoreValue = () => {
    let value = JSON.parse(localStorage.getItem(ROOT));
    return value ? value : {};
  };
  var setStoreValue = (value) => localStorage.setItem(ROOT, JSON.stringify(value));
  var load = (key, defaultValue) => {
    const value = getStoreValue()[key];
    return typeof value === "undefined" ? defaultValue : value;
  };
  var dump = (key, value) => {
    let storeValue = getStoreValue();
    storeValue[key] = value;
    setStoreValue(storeValue);
  };
  var erase = (key) => {
    let store = getStoreValue();
    delete store[key];
    setStoreValue(store);
  };
  var migrateHistory = (history) => {
    if (!history || !Array.isArray(history)) return history;
    return history.map(
      (round) => round.map((match) => {
        if ("isFreeGame" in match) {
          return match;
        }
        if (match instanceof RegularMatch) {
          return match;
        }
        return RegularMatch.fromPlainObject(match);
      })
    );
  };
  var ensureSetsToWin = () => {
    const setsToWin = load("setsToWin");
    if (setsToWin === void 0 || setsToWin === null) {
      dump("setsToWin", 1);
      return 1;
    }
    return setsToWin;
  };

  // app/types.ts
  var RegularMatch = class _RegularMatch {
    constructor(teams, setsWon = [null, null]) {
      this.teams = teams;
      this.setsWon = setsWon;
    }
    get winningTeam() {
      if (this.setsWon[0] === null || this.setsWon[1] === null) {
        return null;
      }
      const setsToWin = load("setsToWin", 1);
      if (this.setsWon[0] === setsToWin && this.setsWon[1] !== setsToWin) return 0;
      if (this.setsWon[1] === setsToWin && this.setsWon[0] !== setsToWin) return 1;
      return null;
    }
    static fromPlainObject(obj) {
      if (obj.setsWon !== void 0) {
        return new _RegularMatch(obj.teams, obj.setsWon);
      } else if (obj.winningTeam !== void 0 && obj.winningTeam !== null) {
        const setsWon = obj.winningTeam === 0 ? [1, 0] : [0, 1];
        return new _RegularMatch(obj.teams, setsWon);
      } else {
        return new _RegularMatch(obj.teams, [null, null]);
      }
    }
    toJSON() {
      return {
        teams: this.teams,
        setsWon: this.setsWon
      };
    }
  };

  // app/pairingStrategy.ts
  var DEFAULT_PAIRING_STRATEGY = "power-pairing";
  var pairTeams = (teams, ranking, strategy = DEFAULT_PAIRING_STRATEGY) => {
    if (strategy === "random") {
      return pairTeamsRandomly(teams);
    } else {
      return pairTeamsByPower(teams, ranking);
    }
  };
  var pairTeamsByPower = (teams, ranking) => {
    teams = sortTeamsByRanking(teams, ranking);
    let matches = [];
    for (let i = 0; i < teams.length; i += 2) {
      matches.push(
        new RegularMatch([teams[i], teams[i + 1]], [null, null])
      );
    }
    return matches;
  };
  var pairTeamsRandomly = (teams) => {
    const shuffled = [...teams];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    let matches = [];
    for (let i = 0; i < shuffled.length; i += 2) {
      matches.push(
        new RegularMatch(
          [shuffled[i], shuffled[i + 1]],
          [null, null]
        )
      );
    }
    return matches;
  };

  // app/tournament.ts
  var tournamentHasStarted = (history) => isTruthy(history);
  var tournamentHasFinished = (history, roundCount) => {
    return history.length == roundCount && !roundIsOpen(history[roundCount - 1]);
  };
  var calculateCurrentRound = () => {
    const history = load("history");
    return history.length;
  };
  var getActiveParticipants = () => {
    const participants = load("participants");
    let departedPlayers = load("departedPlayers", {});
    return participants.filter((participant) => {
      return !(participant in departedPlayers);
    });
  };
  var incrementRoundCount = () => {
    const history = load("history", []);
    if (!tournamentHasStarted(history)) {
      return false;
    }
    const currentRoundCount = load("roundCount");
    dump("roundCount", currentRoundCount + 1);
    return true;
  };

  // app/dom.ts
  var readFromInputField = (id) => document.getElementById(id).value;
  var writeToInputField = (id, value) => {
    ;
    document.getElementById(id).value = value;
    return true;
  };
  function htmlElement(tag, html) {
    html = html.trim();
    const template = document.createElement("template");
    template.innerHTML = html;
    const result = template.content.children;
    if (result.length !== 1) {
      throw new Error(`Expected exactly one element, got ${result.length}`);
    }
    const element = result[0];
    if (element.tagName.toLowerCase() !== tag.toLowerCase()) {
      throw new Error(
        `Element tag mismatch: expected ${tag}, got ${element.tagName.toLowerCase()}`
      );
    }
    return element;
  }

  // app/components/alert.ts
  var createAlert = (message, callback = null) => {
    message = message.trim();
    const id = randomId();
    if (callback) {
      const dom = htmlElement(
        "div",
        `
      <div id=${id} class="alert">
        <div class="alert-body">
          <div class="alert-message">
            ${message}
          </div>
          <div class="flex">
            <button
              id="action-confirm-alert-${id}"
              class="btn btn-alert"
            >
              Ja
            </button>
            <button
              id="action-cancel-alert-${id}"
              class="btn btn-action right"
            >
              Abbrechen
            </button>
          </div>
        </div>
      </div>
    `
      );
      document.getElementById("universe").appendChild(dom);
      document.getElementById(`action-confirm-alert-${id}`).addEventListener("click", () => {
        destroyAlert(id);
        callback();
      });
      document.getElementById(`action-cancel-alert-${id}`).addEventListener("click", () => {
        destroyAlert(id);
      });
    } else {
      const dom = htmlElement(
        "div",
        `
      <div id=${id} class="alert">
        <div class="alert-body">
          <div class="alert-message">
            ${message}
          </div>
          <div class="flex">
            <button
              id="action-close-alert-${id}"
              class="btn btn-action right"
            >
              OK
            </button>
          </div>
        </div>
      </div>
    `
      );
      document.getElementById("universe").appendChild(dom);
      document.getElementById(`action-close-alert-${id}`).addEventListener("click", () => destroyAlert(id));
      document.getElementById(id).addEventListener("click", (e) => {
        if (e.target.id === id) destroyAlert(id);
      });
    }
  };
  var destroyAlert = (id) => {
    document.getElementById(id)?.remove();
  };

  // app/round.ts
  var determineNextRound = (history) => {
    const activeParticipants = getActiveParticipants();
    let [teams, freeGamers] = determineTeams(activeParticipants, history);
    const rankingOrder = getRankingOrder();
    let ranking = calculateRanking(activeParticipants, history, rankingOrder);
    const pairingStrategy = load(
      "pairingStrategy",
      DEFAULT_PAIRING_STRATEGY
    );
    return [
      ...pairTeams(teams, ranking, pairingStrategy),
      ...freeGameMatches(freeGamers)
    ];
  };
  var freeGameMatches = (freeGamers) => {
    let matches = [];
    for (const freeGamer of freeGamers) {
      matches.push({
        isFreeGame: true,
        player: freeGamer
      });
    }
    return matches;
  };
  var determineTeams = (participants, history) => {
    const forbiddenPairings = calculateForbiddenPartners(participants, history);
    const freeGameStrategy = load(
      "freeGameStrategy",
      DEFAULT_FREE_GAME_STRATEGY
    );
    const freeGamers = calculateFreeGamers(
      participants,
      history,
      freeGameStrategy
    );
    if (history.length == 0) {
      return [determineTeamsForFirstRound(participants, freeGamers), freeGamers];
    }
    return [
      drawTeams(participants, forbiddenPairings, [...freeGamers]),
      [...freeGamers]
    ];
  };
  var drawTeams = (participants, forbiddenPartners, freeGamers) => {
    const players = setDiff(participants, freeGamers);
    let teams = [];
    while (players.size > 0) {
      const [playerOne] = players;
      players.delete(playerOne);
      const possiblePartners = setDiff(
        [...players],
        [...forbiddenPartners[playerOne]]
      );
      if (possiblePartners.size == 0) {
        return drawTeams(participants, forbiddenPartners, freeGamers);
      }
      const playerTwo = drawRandom(possiblePartners);
      players.delete(playerTwo);
      teams.push([playerOne, playerTwo]);
    }
    return teams;
  };
  var determineTeamsForFirstRound = (participants, freeGamers) => {
    const players = [...setDiff(participants, freeGamers)];
    let teams = [];
    const breakIndex = players.length / 2;
    const topHalf = players.slice(0, breakIndex);
    const bottomHalf = players.slice(breakIndex, players.length);
    for (const topPlayer of topHalf) {
      const bottomPlayer = popRandom(bottomHalf);
      teams.push([topPlayer, bottomPlayer]);
    }
    return teams;
  };
  var calculateForbiddenPartners = (participants, history) => {
    const allParticipants = load("participants");
    let forbiddenPartners = {};
    for (const participant of allParticipants) {
      forbiddenPartners[participant] = /* @__PURE__ */ new Set([participant]);
    }
    for (const round of history) {
      for (const match of round) {
        if ("isFreeGame" in match) {
          continue;
        }
        for (const team of match.teams) {
          forbiddenPartners[team[0]].add(team[1]);
          forbiddenPartners[team[1]].add(team[0]);
        }
      }
    }
    return forbiddenPartners;
  };
  var roundIsOpen = (round) => {
    return round.some((match) => {
      if ("isFreeGame" in match) {
        return false;
      }
      return match.winningTeam === null || match.winningTeam === void 0;
    });
  };
  var resetNextRound = () => {
    const history = load("history");
    const roundCount = load("roundCount");
    history.pop();
    dump("history", history);
    setNextRound(history, roundCount);
  };
  var setNextRound = (history, roundCount) => {
    if (calculateCurrentRound() == roundCount) return;
    const activeParticipants = getActiveParticipants();
    const nextRoundNumber = history.length + 1;
    if (nextRoundNumber > activeParticipants.length) {
      createAlert(`
      Warnung: Es wird versucht, Runde ${nextRoundNumber} zu erstellen,
      aber es gibt nur ${activeParticipants.length} aktive Teilnehmer:innen.

      Die Anzahl der Runden kann die Anzahl der Teilnehmer:innen nicht
      \xFCberschreiten, da sonst keine g\xFCltigen Paarungen mehr m\xF6glich sind (weil
      keine zwei Spieler:innen zweimal zusammen spielen sollen).
    `);
      return;
    }
    const newHistory = [...history, determineNextRound(history)];
    dump("history", newHistory);
  };

  // app/ranking.ts
  var calculatePoints = (participants, history) => {
    let ranking = {};
    for (const participant of participants) {
      ranking[participant] = 0;
    }
    for (const round of history) {
      if (roundIsOpen(round)) {
        continue;
      }
      for (const match of round) {
        if ("isFreeGame" in match) {
          ranking[match.player] += 1;
          continue;
        }
        const winningTeam = match.winningTeam;
        for (const winningPlayer of match.teams[winningTeam]) {
          ranking[winningPlayer] += 1;
        }
      }
    }
    return ranking;
  };
  var calculateBuchholz = (points, history) => {
    const buchholz = {};
    for (const player of Object.keys(points)) {
      buchholz[player] = 0;
    }
    for (const round of history) {
      if (roundIsOpen(round)) {
        continue;
      }
      for (const match of round) {
        if ("isFreeGame" in match) {
          continue;
        }
        const teams = match.teams;
        buchholz[teams[0][0]] -= points[teams[0][1]];
        buchholz[teams[0][1]] -= points[teams[0][0]];
        buchholz[teams[1][0]] -= points[teams[1][1]];
        buchholz[teams[1][1]] -= points[teams[1][0]];
        buchholz[teams[0][0]] += points[teams[1][0]] + points[teams[1][1]];
        buchholz[teams[0][1]] += points[teams[1][0]] + points[teams[1][1]];
        buchholz[teams[1][0]] += points[teams[0][0]] + points[teams[0][1]];
        buchholz[teams[1][1]] += points[teams[0][0]] + points[teams[0][1]];
      }
    }
    return buchholz;
  };
  var calculateSetPoints = (participants, history) => {
    const setPoints = {};
    for (const participant of participants) {
      setPoints[participant] = 0;
    }
    for (const round of history) {
      if (roundIsOpen(round)) {
        continue;
      }
      for (const match of round) {
        if ("isFreeGame" in match) {
          continue;
        }
        if (!("setsWon" in match) || !match.setsWon) {
          continue;
        }
        if (match.setsWon[0] === null || match.setsWon[1] === null) {
          continue;
        }
        const teams = match.teams;
        const setsWon0 = match.setsWon[0];
        const setsWon1 = match.setsWon[1];
        setPoints[teams[0][0]] += setsWon0 - setsWon1;
        setPoints[teams[0][1]] += setsWon0 - setsWon1;
        setPoints[teams[1][0]] += setsWon1 - setsWon0;
        setPoints[teams[1][1]] += setsWon1 - setsWon0;
      }
    }
    return setPoints;
  };
  var getDefaultRankingOrder = (setsToWin) => {
    if (setsToWin !== void 0 && setsToWin !== null && setsToWin > 1) {
      return ["points", "setPoints", "buchholz"];
    }
    return ["points", "buchholz"];
  };
  var getRankingOrder = () => {
    const setsToWin = load("setsToWin");
    if (setsToWin === void 0 || setsToWin === null || setsToWin === 1) {
      return ["points", "buchholz"];
    }
    const rankingOrder = load("rankingOrder");
    const availableParams = [
      "points",
      "buchholz",
      "setPoints"
    ];
    if (rankingOrder && Array.isArray(rankingOrder)) {
      const filtered = rankingOrder.filter(
        (p) => availableParams.includes(p)
      );
      const missing = availableParams.filter(
        (p) => !filtered.includes(p)
      );
      return [...filtered, ...missing];
    }
    return getDefaultRankingOrder(setsToWin);
  };
  var getRankingValue = (row, param) => {
    switch (param) {
      case "points":
        return row[1];
      case "buchholz":
        return row[2];
      case "setPoints":
        return row[3];
    }
  };
  var createRankingSort = (order) => {
    return (here, there) => {
      for (const param of order) {
        const hereValue = getRankingValue(here, param);
        const thereValue = getRankingValue(there, param);
        if (thereValue !== hereValue) {
          return thereValue - hereValue;
        }
      }
      return 0;
    };
  };
  var calculateRanking = (participants, history, rankingOrder) => {
    const order = rankingOrder || getRankingOrder();
    let points = calculatePoints(participants, history);
    let buchholz = calculateBuchholz(points, history);
    let setPoints = calculateSetPoints(participants, history);
    let ranking = participants.map((participant) => [
      participant,
      points[participant],
      buchholz[participant],
      setPoints[participant]
    ]);
    return ranking.sort(createRankingSort(order));
  };
  var sortTeamsByRanking = (teams, ranking) => {
    const rankingMap = {};
    for (const [player, points, buchholz, setPoints] of ranking) {
      rankingMap[player] = [points, buchholz, setPoints];
    }
    teams.sort((thisTeam, otherTeam) => {
      const thisTeamPoints = rankingMap[thisTeam[0]][0] + rankingMap[thisTeam[1]][0];
      const otherTeamPoints = rankingMap[otherTeam[0]][0] + rankingMap[otherTeam[1]][0];
      const thisTeamBuchholz = rankingMap[thisTeam[0]][1] + rankingMap[thisTeam[1]][1];
      const otherTeamBuchholz = rankingMap[otherTeam[0]][1] + rankingMap[otherTeam[1]][1];
      if (thisTeamPoints == otherTeamPoints) {
        return thisTeamBuchholz > otherTeamBuchholz ? -1 : 1;
      }
      return thisTeamPoints > otherTeamPoints ? -1 : 1;
    });
    return teams;
  };

  // app/components/dataForm.ts
  var createDataForm = () => {
    const dataForm = htmlElement(
      "div",
      `
    <div id="data-form">
      <h1>Turnierdaten</h1>
      <div class="flex">
        <div class="flex-grow">
          <div class="label">Name</div>
          <input id="input-title" class="input" type="text" />
        </div>

        <div class="number-input-group">
          <div class="label">Runden</div>
          <input
            id="input-round-count"
            class="input input-number"
            type="number"
            value="5"
          />
        </div>

        <div class="number-input-group">
          <div class="label">Gewinns\xE4tze</div>
          <input
            id="input-sets-to-win"
            class="input input-number"
            type="number"
            min="1"
            max="10"
            value="1"
          />
        </div>
      </div>

      <div class="flex">
        <div class="flex-section">
          <div class="label">Freilos-Vergabe</div>
          <div class="radio-group">
            <label class="radio-label">
              <input
                type="radio"
                name="free-game-strategy"
                value="bottom-ranking"
                id="radio-bottom-ranking"
                checked
              />
              Von Unten
            </label>
            <label class="radio-label">
              <input
                type="radio"
                name="free-game-strategy"
                value="random"
                id="radio-random"
              />
              Zuf\xE4llig
            </label>
          </div>
        </div>

        <div class="flex-section">
          <div class="label">Setzung</div>
          <div class="radio-group">
            <label class="radio-label">
              <input
                type="radio"
                name="pairing-strategy"
                value="power-pairing"
                id="radio-power-pairing"
                checked
              />
              Power-Pairing ("Schweizer System")
            </label>
            <label class="radio-label">
              <input
                type="radio"
                name="pairing-strategy"
                value="random"
                id="radio-pairing-random"
              />
              Zuf\xE4llig
            </label>
          </div>
        </div>
      </div>

      <div class="ranking-order-section" id="ranking-order-section" style="display: none;">
        <div class="label">Reihenfolge der Wertung</div>
        <div id="ranking-order-list" class="ranking-order-list"></div>
      </div>

      <div class="textarea-with-numbers">
        <div class="line-numbers" id="participants-line-numbers">1</div>
        <textarea id="input-participants" rows="8" type="text" class="input"></textarea>
      </div>

      <div class="flex">
        <button class="btn btn-action right" id="action-start-tournament">
          Turnier Starten
        </button>
      </div>
    </div>`
    );
    document.getElementById("tournament-data").replaceChildren(dataForm);
    setupLineNumbers();
    updateRankingOrderVisibility();
    document.getElementById("action-start-tournament").addEventListener("click", startTournament);
    document.getElementById("input-sets-to-win").addEventListener("change", () => {
      updateRankingOrderVisibility();
    });
    document.getElementById("input-participants").addEventListener("keyup", (event) => {
      if (event.key == "Enter") {
        onParticipantInputChange();
      }
    });
  };
  var updateLineNumbers = () => {
    const textarea = document.getElementById(
      "input-participants"
    );
    const lineNumbers = document.getElementById("participants-line-numbers");
    const lines = textarea.value.split("\n");
    const numbers = [];
    for (let i = 1; i <= lines.length; i++) {
      numbers.push(i.toString());
    }
    lineNumbers.textContent = numbers.join("\n");
  };
  var setupLineNumbers = () => {
    const textarea = document.getElementById(
      "input-participants"
    );
    const lineNumbers = document.getElementById("participants-line-numbers");
    const syncScroll = () => {
      lineNumbers.scrollTop = textarea.scrollTop;
    };
    textarea.addEventListener("input", updateLineNumbers);
    textarea.addEventListener("scroll", syncScroll);
    textarea.addEventListener("paste", () => {
      setTimeout(updateLineNumbers, 10);
    });
    updateLineNumbers();
  };
  var onParticipantInputChange = () => {
    const input = document.getElementById(
      "input-participants"
    );
    let participants = readParticipants();
    updateLineNumbers();
    dump("participants", participants);
  };
  var readParticipants = () => readFromInputField("input-participants").split("\n").filter((line) => line.trim());
  var readTitle = () => readFromInputField("input-title");
  var readRoundCount = () => Number(readFromInputField("input-round-count"));
  var readSetsToWin = () => Number(readFromInputField("input-sets-to-win"));
  var writeSetsToWin = (setsToWin) => {
    writeToInputField("input-sets-to-win", String(setsToWin));
  };
  var readFreeGameStrategy = () => {
    const bottomRankingRadio = document.getElementById(
      "radio-bottom-ranking"
    );
    if (bottomRankingRadio?.checked) {
      return "bottom-ranking";
    }
    return "random";
  };
  var writeFreeGameStrategy = (strategy) => {
    const bottomRankingRadio = document.getElementById(
      "radio-bottom-ranking"
    );
    const randomRadio = document.getElementById(
      "radio-random"
    );
    if (strategy === "bottom-ranking") {
      if (bottomRankingRadio) bottomRankingRadio.checked = true;
      if (randomRadio) randomRadio.checked = false;
    } else {
      if (bottomRankingRadio) bottomRankingRadio.checked = false;
      if (randomRadio) randomRadio.checked = true;
    }
  };
  var readPairingStrategy = () => {
    const powerPairingRadio = document.getElementById(
      "radio-power-pairing"
    );
    if (powerPairingRadio?.checked) {
      return "power-pairing";
    }
    return "random";
  };
  var writePairingStrategy = (strategy) => {
    const powerPairingRadio = document.getElementById(
      "radio-power-pairing"
    );
    const randomPairingRadio = document.getElementById(
      "radio-pairing-random"
    );
    if (strategy === "power-pairing") {
      if (powerPairingRadio) powerPairingRadio.checked = true;
      if (randomPairingRadio) randomPairingRadio.checked = false;
    } else {
      if (powerPairingRadio) powerPairingRadio.checked = false;
      if (randomPairingRadio) randomPairingRadio.checked = true;
    }
  };
  var getParameterLabel = (param) => {
    switch (param) {
      case "points":
        return "Punkte";
      case "buchholz":
        return "Buchholz";
      case "setPoints":
        return "Satzpunkte";
    }
  };
  var getAvailableParameters = () => {
    const setsToWin = readSetsToWin();
    if (setsToWin !== void 0 && setsToWin !== null && setsToWin > 1) {
      return ["points", "buchholz", "setPoints"];
    }
    return ["points", "buchholz"];
  };
  var shouldShowRankingOrder = () => {
    const setsToWin = readSetsToWin();
    return setsToWin !== void 0 && setsToWin !== null && setsToWin > 1;
  };
  var setupRankingOrder = () => {
    const container = document.getElementById("ranking-order-list");
    if (!container) return;
    const availableParams = getAvailableParameters();
    const currentOrder = readRankingOrder();
    const renderOrder = (order) => {
      container.innerHTML = "";
      order.forEach((param, index) => {
        const row = htmlElement(
          "div",
          `
        <div class="ranking-order-item" data-param="${param}">
          <span class="ranking-order-number">${index + 1}.</span>
          <span class="ranking-order-label">${getParameterLabel(param)}</span>
          <div class="ranking-order-buttons">
            <button class="btn-ranking-order-up" ${index === 0 ? "disabled" : ""} data-index="${index}">\u2191</button>
            <button class="btn-ranking-order-down" ${index === order.length - 1 ? "disabled" : ""} data-index="${index}">\u2193</button>
          </div>
        </div>
      `
        );
        container.appendChild(row);
      });
      container.querySelectorAll(".btn-ranking-order-up").forEach((btn) => {
        btn.addEventListener("click", () => {
          const index = parseInt(btn.dataset.index || "0");
          const newOrder = [...order];
          if (index > 0) {
            ;
            [newOrder[index - 1], newOrder[index]] = [
              newOrder[index],
              newOrder[index - 1]
            ];
            writeRankingOrder(newOrder);
            renderOrder(newOrder);
          }
        });
      });
      container.querySelectorAll(".btn-ranking-order-down").forEach((btn) => {
        btn.addEventListener("click", () => {
          const index = parseInt(btn.dataset.index || "0");
          const newOrder = [...order];
          if (index < newOrder.length - 1) {
            ;
            [newOrder[index], newOrder[index + 1]] = [
              newOrder[index + 1],
              newOrder[index]
            ];
            writeRankingOrder(newOrder);
            renderOrder(newOrder);
          }
        });
      });
    };
    renderOrder(currentOrder);
  };
  var updateRankingOrderVisibility = () => {
    const section = document.getElementById("ranking-order-section");
    if (!section) return;
    if (shouldShowRankingOrder()) {
      section.style.display = "block";
      setupRankingOrder();
    } else {
      section.style.display = "none";
      const defaultOrder = getDefaultRankingOrder(readSetsToWin());
      writeRankingOrder(defaultOrder);
    }
  };
  var readRankingOrder = () => {
    const stored = load("rankingOrder");
    if (stored && Array.isArray(stored)) {
      const availableParams = getAvailableParameters();
      const filtered = stored.filter((p) => availableParams.includes(p));
      const missing = availableParams.filter((p) => !filtered.includes(p));
      return [...filtered, ...missing];
    }
    return getDefaultRankingOrder(readSetsToWin());
  };
  var writeRankingOrder = (order) => {
    dump("rankingOrder", order);
  };

  // app/components/openDialog.ts
  var createOpenDialog = () => {
    destroyOpenDialog();
    const tournaments = Object.keys(load("savedTournaments") || {});
    if (!isTruthy(tournaments)) {
      return;
    }
    const dialog = htmlElement(
      "div",
      `
    <div id="open-dialog" class="dropdown-dialog"></div>
  `
    );
    for (const tournament of tournaments) {
      const link = createOpenLink(tournament);
      dialog.appendChild(link);
    }
    const section = document.getElementById(
      "open-tournament-section"
    );
    section.appendChild(dialog);
    window.addEventListener(
      "click",
      (event) => document.getElementById("open-tournament-section").contains(event.target) || destroyOpenDialog()
    );
  };
  var destroyOpenDialog = () => document.getElementById("open-dialog")?.remove();
  var createOpenLink = (tournamentKey) => {
    const link = htmlElement(
      "div",
      `
    <div class="dropdown-dialog-row action-open-tournament">
      ${tournamentKey}
    </div>
  `
    );
    link.addEventListener("click", () => {
      openTournament(tournamentKey);
      destroyOpenDialog();
    });
    return link;
  };

  // app/components/header.ts
  var createHeader = () => {
    const savedTournaments = load("savedTournaments") || {};
    const hasSavedTournaments = isTruthy(Object.keys(savedTournaments));
    const openTournamentSection = hasSavedTournaments ? `
        <div id="open-tournament-section" class="section">
          <div class="width-100 relative">
            <div class="dropdown width-100">
              <button
                id="action-open-tournament"
                class="btn btn-action btn-yellow width-100"
              >
                \xD6ffnen
              </button>
            </div>
          </div>
        </div>
      ` : "";
    const dom = htmlElement(
      "div",
      `
    <div id="header" class="page">

      <div class="left-group">
        <div id="create-tournament-section" class="section">
          <button
            id="action-create-tournament"
            class="btn btn-action btn-green width-100"
          >
            Neu
          </button>
        </div>

        ${openTournamentSection}
      </div>

      <div class="right-group">
        <div id="export-tournament-section" class="section">
          <button
            id="action-export-tournament"
            class="btn btn-action width-100"
          >
            Exportieren
          </button>
        </div>

        <div id="import-tournament-section" class="section">
          <button
            id="action-import-tournament"
            class="btn btn-action width-100"
          >
            Importieren
          </button>
        </div>

        <input type="file" id="import-tournament-file-input" accept=".json" style="display: none;">

      </div>

    </div>
  `
    );
    document.getElementById("header").replaceWith(dom);
    document.getElementById("action-create-tournament").addEventListener("click", createTournament);
    const openTournamentButton = document.getElementById("action-open-tournament");
    if (openTournamentButton) {
      openTournamentButton.addEventListener("click", createOpenDialog);
    }
    document.getElementById("action-export-tournament").addEventListener("click", exportTournament);
    document.getElementById("action-import-tournament").addEventListener("click", openImportFileDialogue);
    document.getElementById("import-tournament-file-input").addEventListener("change", importTournament);
  };

  // app/components/footer.ts
  var createFooter = () => {
    const dom = htmlElement(
      "footer",
      `
    <footer id="footer">
      Version <strong>1.1.0</strong>
      <br>Dieses Programm ist Open Source und kann kostenlos verwendet werden.
      <br><a href="https://github.com/jnthnhrrr/swissDouble/" target="_blank" rel="noopener noreferrer">Quellcode</a> | <a href="https://github.com/jnthnhrrr/swissDouble/blob/master/SPEZIFIKATIONEN.md" target="_blank" rel="noopener noreferrer">Spezifikationen</a> | <a href="https://github.com/jnthnhrrr/swissDouble/blob/master/LICENSE.md" target="_blank" rel="noopener noreferrer">Lizenz</a>
    </footer>
  `
    );
    const existingFooter = document.getElementById("footer");
    if (existingFooter) {
      existingFooter.replaceWith(dom);
    } else {
      document.getElementById("universe").appendChild(dom);
    }
  };

  // app/components/roundNavigation.ts
  var highlightRoundNavItem = (roundNumber) => {
    let items = document.getElementsByClassName("nav-round");
    for (let index = 1; index <= items.length; index++) {
      const item = items[index - 1];
      item.classList.remove("focus");
      if (index == roundNumber) {
        item.classList.add("focus");
      }
    }
  };
  var createRoundNavigation = (focusedRound) => {
    const currentRound = calculateCurrentRound();
    const history = load("history", []);
    const tournamentStarted = tournamentHasStarted(history);
    let items = [];
    for (let round = 1; round <= focusedRound; round++) {
      let navItem = htmlElement(
        "div",
        `
      <div
        class="
        nav-round
        ${currentRound == round ? "current-round" : ""}
        ${currentRound < round ? "future-round inactive" : ""}
        "
      >
        Runde ${round}
      </div>
    `
      );
      round <= currentRound && navItem.addEventListener("click", () => {
        createRoundView(round);
      });
      items.push(navItem);
    }
    if (tournamentStarted) {
      const roundCount = load("roundCount");
      const activeParticipants = getActiveParticipants();
      if (roundCount < activeParticipants.length) {
        const addRoundButton = htmlElement(
          "div",
          `
        <div class="nav-round add-round-button" id="add-round-button">
          +
        </div>
      `
        );
        addRoundButton.addEventListener("click", () => {
          confirmIncrementRoundCount();
        });
        items.push(addRoundButton);
      }
    }
    destroyRoundNavigation();
    const dom = htmlElement("div", `<div id="round-nav"></div>`);
    dom.replaceChildren(...items);
    document.getElementById("tournament-data").after(dom);
  };
  var destroyRoundNavigation = () => document.getElementById("round-nav")?.remove();
  var confirmIncrementRoundCount = () => {
    const currentRoundCount = load("roundCount");
    createAlert(
      `
    Eine weitere Runde hinzuf\xFCgen?

    Das Turnier wird von ${currentRoundCount} auf ${currentRoundCount + 1} Runden erweitert.
  `,
      () => {
        if (incrementRoundCount()) {
          render();
        }
      }
    );
  };

  // app/components/reopenRoundConfirmation.ts
  var createReopenRoundConfirmation = (roundNumber, openRoundNumber) => {
    const dom = htmlElement(
      "div",
      `
    <div id="reopen-round-confirmation">
      <div class="confirmation-body">
        <div class="confirmation-message">
          Die Runde ${openRoundNumber} ist noch nicht festgeschrieben.

          Wenn du die Ergebnisse von Runde ${roundNumber} korrigierst, wird die
          Runde ${openRoundNumber} neu gesetzt. Falls die Runde
          ${openRoundNumber} schon begonnen hat, korrigiere die Ergebnisse von
          Runde ${roundNumber} erst dann, wenn Runde ${openRoundNumber} beendet
          und festgeschrieben ist.
        </div>

        <div class="flex">
          <button
            id="action-reopen-round"
            class="btn btn-alert"
          >
            Ich m\xF6chte Runde ${roundNumber} korrigeren, Runde ${openRoundNumber}
            wird neu gesetzt.
          </button>

          <button
            id="action-abort-reopen-round"
            class="btn right"
          >
            Abbrechen
          </button>
        </div>

      </div>
    </div>
  `
    );
    document.getElementById("universe").appendChild(dom);
    document.getElementById("action-reopen-round").addEventListener("click", () => {
      reopenRound(roundNumber);
    });
    document.getElementById("action-abort-reopen-round").addEventListener("click", destroyReopenRoundConfirmation);
  };
  var destroyReopenRoundConfirmation = () => {
    document.getElementById("reopen-round-confirmation")?.remove();
  };
  var reopenRound = (roundNumber) => {
    destroyReopenRoundConfirmation();
    dump("correctingRound", roundNumber);
    createRoundView(roundNumber);
  };

  // app/components/roundView.ts
  var freeGameDom = (match, points) => htmlElement(
    "div",
    `
    <div class="match freegame flex">
      <div class="team"><div class="fw-normal">FREISPIEL</div></div>
      <div class="team"><div class="player">${match.player} <span class="points">[${points[match.player]}]</span></div>
    </div>
  `
  );
  var resultDom = (match, editable) => {
    const dom = htmlElement("div", `<div class="result"></div>`);
    const setsToWin = load("setsToWin", 1);
    const displayValue = (value) => {
      return value === null ? "?" : String(value);
    };
    const teamOneResultDom = htmlElement(
      "button",
      `
    <button class="btn btn-result">${displayValue(match.setsWon[0])}</button>
  `
    );
    const teamTwoResultDom = htmlElement(
      "button",
      `
    <button class="btn btn-result second">${displayValue(
        match.setsWon[1]
      )}</button>
  `
    );
    let matchElement = null;
    const updateVisualFeedback = () => {
      const team0Value = parseButtonValue(teamOneResultDom.innerHTML);
      const team1Value = parseButtonValue(teamTwoResultDom.innerHTML);
      teamOneResultDom.classList.remove("set");
      teamTwoResultDom.classList.remove("set");
      if (matchElement) {
        matchElement.classList.remove("tie");
        matchElement.classList.remove("invalid");
      }
      if (team0Value === setsToWin && team1Value !== setsToWin && team1Value !== null) {
        teamOneResultDom.classList.add("set");
      } else if (team1Value === setsToWin && team0Value !== setsToWin && team0Value !== null) {
        teamTwoResultDom.classList.add("set");
      } else if (team0Value !== null && team1Value !== null && team0Value === setsToWin && team1Value === setsToWin) {
        if (matchElement) {
          matchElement.classList.add("tie");
        }
      } else if (team0Value !== null && team1Value === null || team0Value === null && team1Value !== null || team0Value !== null && team1Value !== null && team0Value !== setsToWin && team1Value !== setsToWin) {
        if (matchElement) {
          matchElement.classList.add("invalid");
        }
      }
    };
    const setMatchElement = (element) => {
      matchElement = element;
      updateVisualFeedback();
    };
    if (editable) {
      if (setsToWin === 1) {
        teamOneResultDom.addEventListener("click", () => {
          flipSets(teamOneResultDom, teamTwoResultDom);
          updateVisualFeedback();
        });
        teamTwoResultDom.addEventListener("click", () => {
          flipSets(teamTwoResultDom, teamOneResultDom);
          updateVisualFeedback();
        });
      } else {
        teamOneResultDom.addEventListener("click", () => {
          incrementSets(teamOneResultDom, setsToWin);
          updateVisualFeedback();
        });
        teamTwoResultDom.addEventListener("click", () => {
          incrementSets(teamTwoResultDom, setsToWin);
          updateVisualFeedback();
        });
      }
    }
    updateVisualFeedback();
    dom.appendChild(teamOneResultDom);
    dom.appendChild(htmlElement("span", `<span class="conjunctor">:</span>`));
    dom.appendChild(teamTwoResultDom);
    return {
      dom,
      setMatchElement,
      updateVisualFeedback
    };
  };
  var parseButtonValue = (value) => {
    if (value === "?") return null;
    const num = Number(value);
    return isNaN(num) ? null : num;
  };
  var incrementSets = (buttonDom, setsToWin) => {
    const currentValue = parseButtonValue(buttonDom.innerHTML);
    let nextValue;
    if (currentValue === null) {
      nextValue = 0;
    } else if (currentValue === setsToWin) {
      nextValue = 0;
    } else {
      nextValue = currentValue + 1;
    }
    buttonDom.innerHTML = nextValue === null ? "?" : String(nextValue);
  };
  var flipSets = (clickedButton, opposingButton) => {
    const clickedValue = parseButtonValue(clickedButton.innerHTML);
    if (clickedValue === null || clickedValue === 0) {
      clickedButton.innerHTML = "1";
      opposingButton.innerHTML = "0";
    } else if (clickedValue === 1) {
      clickedButton.innerHTML = "0";
      opposingButton.innerHTML = "1";
    }
  };
  var regularMatchDom = (match, editable, points) => {
    const teamOne = htmlElement(
      "div",
      `
    <div class="team">
      <div class="player">${match.teams[0][0]} <span class="points">[${points[match.teams[0][0]]}]</span></div>
      <div class="player">${match.teams[0][1]} <span class="points">[${points[match.teams[0][1]]}]</span></div>
    </div>
  `
    );
    const teamTwo = htmlElement(
      "div",
      `
    <div class="team">
      <div class="player">${match.teams[1][0]} <span class="points">[${points[match.teams[1][0]]}]</span></div>
      <div class="player">${match.teams[1][1]} <span class="points">[${points[match.teams[1][1]]}]</span></div>
    </div>
  `
    );
    const result = resultDom(match, editable);
    const dom = htmlElement("div", `<div class="match"></div>`);
    dom.appendChild(teamOne);
    dom.appendChild(result.dom);
    dom.appendChild(teamTwo);
    result.setMatchElement(dom);
    const setsToWin = load("setsToWin", 1);
    if (match.setsWon[0] !== null && match.setsWon[1] !== null && match.setsWon[0] === setsToWin && match.setsWon[1] === setsToWin) {
      dom.classList.add("tie");
    } else if (match.setsWon[0] !== null && match.setsWon[1] === null || match.setsWon[0] === null && match.setsWon[1] !== null || match.setsWon[0] !== null && match.setsWon[1] !== null && match.setsWon[0] !== setsToWin && match.setsWon[1] !== setsToWin) {
      dom.classList.add("invalid");
    }
    return dom;
  };
  var createRoundView = (focusedRound) => {
    destroyRoundView();
    let history = load("history");
    if (!isTruthy(history)) return;
    history = migrateHistory(history);
    const participants = load("participants");
    const roundCount = load("roundCount");
    const currentRound = calculateCurrentRound();
    const tournamentIsOver = tournamentHasFinished(history, roundCount);
    const tournamentIsNotOverYet = !tournamentIsOver;
    const focusedRoundIndex = focusedRound - 1;
    const focusedRoundData = history[focusedRoundIndex];
    const isFocusedRoundClosed = focusedRoundData && !roundIsOpen(focusedRoundData);
    const historyForPoints = isFocusedRoundClosed ? history.slice(0, focusedRound) : history.slice(0, focusedRoundIndex);
    const points = calculatePoints(participants, historyForPoints);
    const dom = htmlElement(
      "div",
      `<div id="round-view" class="page border"></div>`
    );
    const roundIsCurrent = focusedRound == currentRound;
    const roundIsOpen2 = roundIsCurrent && tournamentIsNotOverYet;
    const roundIsBeingCorrected = load("correctingRound") == focusedRound;
    const roundIsEditable = roundIsOpen2 || roundIsBeingCorrected;
    roundIsEditable ? dom.classList.add("editable-round") : dom.classList.add("fixed-round");
    const round = history[focusedRound - 1];
    let heading = htmlElement(
      "div",
      `
    <div class="flex"><h2 class="center">Runde ${focusedRound}</h2></div
  `
    );
    let matchDoms = [];
    for (const match of round) {
      "isFreeGame" in match ? matchDoms.push(freeGameDom(match, points)) : matchDoms.push(regularMatchDom(match, roundIsEditable, points));
    }
    dom.replaceChildren(heading, ...matchDoms);
    if (roundIsEditable) {
      const closeButton = htmlElement(
        "div",
        `
      <div class="flex">
        <button
          id="action-fix-round"
          class="btn btn-action right"
        >
          Runde Festschreiben
        </button>
      </div>
    `
      );
      closeButton.addEventListener("click", () => {
        closeRound(focusedRound);
      });
      dom.appendChild(closeButton);
    } else {
      const reOpenButton = htmlElement(
        "div",
        `
      <div class="flex">
        <button
          id="action-attempt-reopen-round"
          class="btn btn-alert right"
        >
          Fehler korrigieren
        </button>
      </div>
    `
      );
      reOpenButton.addEventListener(
        "click",
        () => attemptReopenRound(focusedRound)
      );
      dom.appendChild(reOpenButton);
    }
    ;
    document.getElementById("round-nav").after(dom);
    highlightRoundNavItem(focusedRound);
  };
  var destroyRoundView = () => document.getElementById("round-view")?.remove();
  var closeRound = (roundNumber) => {
    const history = load("history");
    const roundCount = load("roundCount");
    const correctingThisRound = load("correctingRound") != void 0;
    const setsToWin = load("setsToWin", 1);
    const round = history[roundNumber - 1];
    const resultButtons = document.querySelectorAll(
      "#round-view .match:not(.freegame) .result .btn-result"
    );
    let buttonIndex = 0;
    for (let matchIndex = 0; matchIndex < round.length; matchIndex++) {
      const match = round[matchIndex];
      if ("isFreeGame" in match) {
        continue;
      }
      const team0Button = resultButtons[buttonIndex];
      const team1Button = resultButtons[buttonIndex + 1];
      if (!team0Button || !team1Button) {
        createAlert(`
        Fehler beim Lesen der Ergebnisse.
      `);
        return;
      }
      const team0Value = parseButtonValue(team0Button.innerHTML);
      const team1Value = parseButtonValue(team1Button.innerHTML);
      const team0HasWin = team0Value === setsToWin && team1Value !== setsToWin && team1Value !== null;
      const team1HasWin = team1Value === setsToWin && team0Value !== setsToWin && team0Value !== null;
      const isTie = team0Value !== null && team1Value !== null && team0Value === setsToWin && team1Value === setsToWin;
      const isPartialEntry = team0Value !== null && team1Value === null || team0Value === null && team1Value !== null;
      const isInvalid = team0Value !== null && team1Value !== null && team0Value !== setsToWin && team1Value !== setsToWin;
      if (isTie) {
        createAlert(`
        Die Runde kann noch nicht festgeschrieben werden,
        weil ein Unentschieden nicht erlaubt ist. Ein Team muss genau ${setsToWin} S\xE4tze gewinnen.
      `);
        return;
      }
      if (isPartialEntry) {
        createAlert(`
        Die Runde kann noch nicht festgeschrieben werden,
        weil noch Ergebnisse fehlen. Ein Team muss genau ${setsToWin} S\xE4tze gewinnen.
      `);
        return;
      }
      if (isInvalid) {
        createAlert(`
        Die Runde kann noch nicht festgeschrieben werden,
        weil noch Ergebnisse fehlen. Ein Team muss genau ${setsToWin} S\xE4tze gewinnen.
      `);
        return;
      }
      if (!team0HasWin && !team1HasWin) {
        createAlert(`
        Die Runde kann noch nicht festgeschrieben werden,
        weil noch Ergebnisse fehlen. Ein Team muss genau ${setsToWin} S\xE4tze gewinnen.
      `);
        return;
      }
      const regularMatch = match;
      if (team0Value === null || team1Value === null) {
        createAlert(`
        Die Runde kann noch nicht festgeschrieben werden,
        weil noch Ergebnisse fehlen. Ein Team muss genau ${setsToWin} S\xE4tze gewinnen.
      `);
        return;
      }
      regularMatch.setsWon = [team0Value, team1Value];
      if (regularMatch.winningTeam === null) {
        createAlert(`
        Fehler beim Festschreiben der Ergebnisse. Bitte versuche es erneut.
      `);
        return;
      }
      buttonIndex += 2;
    }
    history[roundNumber - 1] = round;
    dump("history", history);
    if (correctingThisRound) {
      erase("correctingRound");
      resetNextRound();
    }
    setNextRound(history, roundCount);
    render();
  };
  var attemptReopenRound = (roundNumber) => {
    const history = load("history");
    const roundCount = load("roundCount");
    if (tournamentHasFinished(history, roundCount)) {
      reopenRound(roundNumber);
      return;
    }
    const currentRoundNumber = calculateCurrentRound();
    createReopenRoundConfirmation(roundNumber, currentRoundNumber);
  };

  // app/components/managePlayersDialog.ts
  var createManagePlayersDialog = () => {
    const participants = load("participants") || [];
    const departedPlayers = load("departedPlayers") || {};
    const currentRound = calculateCurrentRound();
    const activePlayers = participants.filter(
      (player) => !departedPlayers[player]
    );
    if (activePlayers.length === 0) {
      createAlert("Alle Spieler:innen haben das Turnier bereits verlassen.");
      return;
    }
    const playerRows = activePlayers.map((player) => {
      const rankingOrder = getRankingOrder();
      const ranking = calculateRanking(
        participants,
        load("history") || [],
        rankingOrder
      );
      const playerRanking = ranking.find(([name]) => name === player);
      const points = playerRanking ? playerRanking[1] : 0;
      return `
      <div class="manage-player-row">
        <div class="player-info">
          <div class="player-name">${player}</div>
          <div class="player-points">${points} Punkte</div>
        </div>
        <button class="btn btn-alert remove-player-btn" data-player="${player}">
          Entfernen
        </button>
      </div>
    `;
    }).join("");
    const dom = htmlElement(
      "div",
      `
    <div id="manage-players-dialog" class="alert">
      <div class="alert-body manage-players-body">
        <h2>Spieler verwalten</h2>
        <div class="manage-players-subtitle">
          Entfernung nach Runde ${currentRound - 1}
        </div>

        <div class="manage-players-list">
          ${playerRows}
        </div>

        <div class="flex">
          <button id="action-close-manage-players" class="btn btn-action right">
            Schlie\xDFen
          </button>
        </div>
      </div>
    </div>
  `
    );
    document.getElementById("universe").appendChild(dom);
    dom.querySelectorAll(".remove-player-btn").forEach((element) => {
      const button = element;
      button.addEventListener("click", (e) => {
        const player = e.target.dataset.player;
        confirmRemovePlayer(player, currentRound - 1);
      });
    });
    dom.querySelector("#action-close-manage-players").addEventListener("click", destroyManagePlayersDialog);
  };
  var destroyManagePlayersDialog = () => {
    document.getElementById("manage-players-dialog")?.remove();
  };
  var confirmRemovePlayer = (player, afterRound) => {
    const roundCount = load("roundCount");
    const activePlayers = (load("participants") || []).filter(
      (p) => !(p in (load("departedPlayers") || {}))
    );
    const willCauseRoundCountIssue = roundCount === activePlayers.length;
    let message = `
    Spieler:in "${player}" nach Runde ${afterRound} entfernen?

    Diese Aktion kann nicht r\xFCckg\xE4ngig gemacht werden.
    Nach dieser Aktion wird die gegenw\xE4rtig offene Runde neu gesetzt.
    Stell sicher, dass die Runde noch nicht begonnen hat.
    Entferne die Spieler:in erst, wenn die Runde abgeschlossen ist.
  `;
    if (willCauseRoundCountIssue) {
      message = `
      Spieler:in "${player}" nach Runde ${afterRound} entfernen?

      WARNUNG: Das Turnier hat derzeit ${roundCount} Runden und ${activePlayers.length} aktive Spieler:innen.
      Nach dem Entfernen dieser Spieler:in wird die Anzahl der Runden
      automatisch auf ${activePlayers.length - 1} reduziert,
      da die Anzahl der Runden die Anzahl der Teilnehmer:innen nicht
      \xFCberschreiten darf.

      Diese Aktion kann nicht r\xFCckg\xE4ngig gemacht werden.
      Nach dieser Aktion wird die gegenw\xE4rtig offene Runde neu gesetzt.
      Stell sicher, dass die Runde noch nicht begonnen hat.
      Entferne die Spieler:in erst, wenn die Runde abgeschlossen ist.
    `;
    }
    createAlert(message, () => removePlayer(player, afterRound));
  };
  var removePlayer = (player, afterRound) => {
    const departedPlayers = load("departedPlayers") || {};
    departedPlayers[player] = afterRound;
    dump("departedPlayers", departedPlayers);
    const roundCount = load("roundCount");
    const participants = load("participants") || [];
    const newActivePlayers = participants.filter(
      (p) => !(p in departedPlayers)
    );
    if (roundCount > newActivePlayers.length) {
      dump("roundCount", newActivePlayers.length);
    }
    destroyManagePlayersDialog();
    resetNextRound();
    render();
  };

  // app/components/rankingTable.ts
  var titleDom = (title) => htmlElement(
    "div",
    `
    <div class="flex"><h1 class="center">${title}</h1></div>
  `
  );
  var headingDom = (round, tournamentIsOver) => tournamentIsOver ? htmlElement(
    "div",
    `<div class=flex><h2 class="center">Endstand</h2></div>`
  ) : htmlElement(
    "div",
    `
      <div class=flex>
        <h2 class="center">Zwischenstand nach Runde ${round}</h2>
      </div>
    `
  );
  var managePlayersButtonDom = () => {
    const dom = htmlElement(
      "div",
      `
    <div class="flex">
      <button id="action-manage-players" class="btn btn-action center">
        Spieler verwalten
      </button>
    </div>
  `
    );
    dom.querySelector("#action-manage-players").addEventListener("click", createManagePlayersDialog);
    return dom;
  };
  var getParameterLabel2 = (param) => {
    switch (param) {
      case "points":
        return "Punkte";
      case "buchholz":
        return "Buchholz";
      case "setPoints":
        return "Satzpunkte";
    }
  };
  var getParameterValue = (row, param) => {
    switch (param) {
      case "points":
        return String(row[1]);
      case "buchholz":
        return String(row[2]);
      case "setPoints": {
        const value = row[3];
        return value > 0 ? `+${value}` : value < 0 ? `${value}` : "0";
      }
    }
  };
  var tableDom = (rankingGroups, departedPlayers, rankingOrder) => {
    const dom = htmlElement("table", `<table class="result-table"></table>`);
    const rows = [];
    const headerCells = [
      "<th>Platz</th>",
      "<th>Name</th>",
      ...rankingOrder.map((param) => `<th>${getParameterLabel2(param)}</th>`)
    ];
    rows.push(htmlElement("tr", `<tr>${headerCells.join("")}</tr>`));
    let rank = 1;
    let dark = true;
    for (const group of rankingGroups) {
      for (const row of group) {
        const [name] = row;
        const isDeparted = departedPlayers && departedPlayers[name] !== void 0;
        const departedText = isDeparted ? ` (nach Runde ${departedPlayers[name]})` : "";
        const dataCells = [
          `<td>${rank}</td>`,
          `<td>${name}${departedText}</td>`,
          ...rankingOrder.map(
            (param) => `<td>${getParameterValue(row, param)}</td>`
          )
        ];
        rows.push(
          htmlElement(
            "tr",
            `
          <tr class="${dark ? "dark" : "bright"} ${isDeparted ? "departed" : ""}">
            ${dataCells.join("")}
          </tr>
        `
          )
        );
      }
      dark = !dark;
      rank += group.length;
    }
    dom.replaceChildren(...rows);
    return dom;
  };
  var groupRankingByPointsAndBuchholz = (ranking) => {
    return groupBy(
      ranking,
      ([thisPlayer, thisPoints, thisBuchholz, thisSetPoints], [thatPlayer, thatPoints, thatBuchholz, thatSetPoints]) => thisPoints == thatPoints && thisBuchholz == thatBuchholz && thisSetPoints == thatSetPoints
    );
  };
  var createRankingTable = (participants, history) => {
    if (!participants) return;
    const rankingOrder = getRankingOrder();
    const ranking = calculateRanking(participants, history, rankingOrder);
    const groups = groupRankingByPointsAndBuchholz(ranking);
    const title = load("title");
    const roundCount = load("roundCount");
    const currentRound = calculateCurrentRound();
    const departedPlayers = load("departedPlayers") || {};
    let rankedRound = 0;
    if (currentRound) {
      rankedRound = roundIsOpen(history[currentRound - 1]) ? currentRound - 1 : currentRound;
    }
    const dom = htmlElement("div", `<div id="ranking-table"></div>`);
    const tournamentFinished = tournamentHasFinished(history, roundCount);
    const showManageButton = tournamentHasStarted(history) && !tournamentHasFinished(history, roundCount);
    const elements = [
      titleDom(title),
      headingDom(rankedRound, tournamentFinished),
      ...showManageButton ? [managePlayersButtonDom()] : [],
      tableDom(groups, departedPlayers, rankingOrder)
    ];
    dom.replaceChildren(...elements);
    document.getElementById("tournament-data").replaceChildren(dom);
  };

  // app/app.ts
  if (typeof window !== "undefined") {
    window.onload = () => render();
  }
  var render = () => {
    destroyRoundNavigation();
    destroyRoundView();
    const participants = load("participants", []);
    let history = load("history", []);
    history = migrateHistory(history);
    ensureSetsToWin();
    const roundCount = load("roundCount");
    const title = load("title");
    document.title = title;
    createHeader();
    createFooter();
    if (tournamentHasStarted(history)) {
      const participants2 = load("participants") || [];
      createRankingTable(participants2, history);
      createRoundNavigation(roundCount);
      createRoundView(calculateCurrentRound());
      return;
    }
    createDataForm();
    dump("history", []);
    title && writeToInputField("input-title", load("title"));
    participants && writeToInputField("input-participants", participants.join("\n")) && onParticipantInputChange();
    roundCount && writeToInputField("input-round-count", String(roundCount)) && createRoundNavigation(roundCount);
    const freeGameStrategy = load(
      "freeGameStrategy",
      DEFAULT_FREE_GAME_STRATEGY
    );
    writeFreeGameStrategy(freeGameStrategy);
    const pairingStrategy = load("pairingStrategy", DEFAULT_PAIRING_STRATEGY);
    writePairingStrategy(pairingStrategy);
    const setsToWin = load("setsToWin", 1);
    writeSetsToWin(setsToWin);
    const rankingOrder = load("rankingOrder");
    if (rankingOrder && setsToWin > 1) {
      writeRankingOrder(rankingOrder);
    } else {
      const defaultOrder = getDefaultRankingOrder(setsToWin);
      writeRankingOrder(defaultOrder);
    }
  };
  var startTournament = () => {
    storeTournament();
    const history = load("history") || [];
    if (tournamentHasStarted(history)) return;
    const participants = readParticipants();
    const duplicates = findDuplicates(participants);
    if (isTruthy(duplicates)) {
      createAlert(`
      Die folgenden Eintr\xE4ge tauchen doppelt auf:

          ${duplicates.join("\n")}

      Bitte \xE4ndere die Eintr\xE4ge, um sie zu vereindeutigen.
    `);
      return;
    }
    const roundCount = readRoundCount();
    if (roundCount > participants.length) {
      createAlert(`
      Die Anzahl der Runden (${roundCount}) darf die Anzahl der Teilnehmer:innen (${participants.length}) nicht \xFCberschreiten.

      Bitte reduziere die Anzahl der Runden oder f\xFCge weitere Teilnehmer:innen hinzu.
    `);
      return;
    }
    const freeGameStrategy = readFreeGameStrategy();
    const pairingStrategy = readPairingStrategy();
    const setsToWin = readSetsToWin();
    dump("participants", participants);
    dump("roundCount", roundCount);
    dump("title", readTitle());
    dump("freeGameStrategy", freeGameStrategy);
    dump("pairingStrategy", pairingStrategy);
    dump("setsToWin", setsToWin);
    const rankingOrder = readRankingOrder();
    dump("rankingOrder", rankingOrder);
    dump("history", history);
    setNextRound(history, roundCount);
    render();
  };
  var createTournament = () => {
    storeTournament();
    for (const key of STORAGE_KEYS) {
      if (key !== "savedTournaments") {
        erase(key);
      }
    }
    render();
  };
  var storeTournament = () => {
    const history = load("history");
    if (!tournamentHasStarted(history)) return;
    const title = load("title");
    const tournament = {
      title,
      history: load("history"),
      participants: load("participants"),
      roundCount: load("roundCount"),
      departedPlayers: load("departedPlayers"),
      freeGameStrategy: load("freeGameStrategy", DEFAULT_FREE_GAME_STRATEGY),
      pairingStrategy: load("pairingStrategy", DEFAULT_PAIRING_STRATEGY),
      setsToWin: load("setsToWin", 1)
    };
    let storeValue = load("savedTournaments") || {};
    storeValue[title] = tournament;
    dump("savedTournaments", storeValue);
  };
  var openTournament = (title) => {
    storeTournament();
    const savedTournaments = load("savedTournaments");
    const tournament = {
      ...savedTournaments[title],
      freeGameStrategy: savedTournaments[title].freeGameStrategy || DEFAULT_FREE_GAME_STRATEGY,
      pairingStrategy: savedTournaments[title].pairingStrategy || DEFAULT_PAIRING_STRATEGY,
      setsToWin: savedTournaments[title].setsToWin || 1
    };
    if (tournament.history) {
      tournament.history = migrateHistory(tournament.history);
    }
    for (const key of Object.keys(tournament)) {
      dump(key, tournament[key]);
    }
    render();
  };
  var downloadJSON = (data, filename) => {
    const jsonString = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  var exportTournament = () => {
    const title = load("title");
    const data = {};
    for (const key of STORAGE_KEYS) {
      const value = load(key);
      if (value !== null) {
        data[key] = value;
      }
    }
    downloadJSON(data, title + ".json");
  };
  var openImportFileDialogue = () => {
    document.getElementById("import-tournament-file-input").click();
  };
  var importTournament = (event) => {
    const file = event.target.files[0];
    if (!file) {
      return;
    }
    const reader = new FileReader();
    reader.onload = function(e) {
      const data = JSON.parse(e.target.result);
      if (data.savedTournaments) {
        const savedTournaments = data.savedTournaments;
        for (const title in savedTournaments) {
          if (!savedTournaments[title].freeGameStrategy) {
            savedTournaments[title].freeGameStrategy = DEFAULT_FREE_GAME_STRATEGY;
          }
          if (!savedTournaments[title].pairingStrategy) {
            savedTournaments[title].pairingStrategy = DEFAULT_PAIRING_STRATEGY;
          }
        }
        data.savedTournaments = savedTournaments;
      }
      if (!data.freeGameStrategy) {
        data.freeGameStrategy = DEFAULT_FREE_GAME_STRATEGY;
      }
      if (!data.pairingStrategy) {
        data.pairingStrategy = DEFAULT_PAIRING_STRATEGY;
      }
      if (!data.setsToWin) {
        data.setsToWin = 1;
      }
      if (data.history) {
        data.history = migrateHistory(data.history);
      }
      if (data.savedTournaments) {
        for (const title in data.savedTournaments) {
          if (data.savedTournaments[title].history) {
            data.savedTournaments[title].history = migrateHistory(
              data.savedTournaments[title].history
            );
          }
          if (!data.savedTournaments[title].setsToWin) {
            data.savedTournaments[title].setsToWin = 1;
          }
        }
      }
      for (const key of Object.keys(data)) {
        const value = data[key];
        dump(key, value);
      }
      render();
    };
    reader.readAsText(file);
  };

  // app/main.ts
  document.addEventListener("DOMContentLoaded", () => {
    console.log("App loaded");
  });
})();
</script>
  </head>

  <body>
    <div id="universe">
      <div id="header"></div>
      <div id="tournament-data" class="page border"></div>
      <div id="round-nav"></div>
      <div id="round"></div>
      <div id="footer"></div>
    </div>
  </body>
</html>
